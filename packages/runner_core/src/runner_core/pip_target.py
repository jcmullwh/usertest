from __future__ import annotations

import json
import shlex
from dataclasses import dataclass
from pathlib import Path
from typing import Final, Literal

PIP_REPO_PREFIXES: Final[tuple[str, ...]] = ("pip:", "pypi:", "pdm:")
PIP_TARGET_DIRNAME: Final[str] = ".usertest"
PIP_REQUIREMENTS_FILENAME: Final[str] = "requirements.txt"
PIP_TARGET_METADATA_FILENAME: Final[str] = "pip_target.json"


@dataclass(frozen=True)
class PipTargetSpec:
    installer: Literal["pip", "pdm"]
    requirements: tuple[str, ...]


def is_pip_repo_input(repo: str) -> bool:
    if not isinstance(repo, str):
        return False
    stripped = repo.strip()
    if not stripped:
        return False
    lowered = stripped.lower()
    return any(lowered.startswith(prefix) for prefix in PIP_REPO_PREFIXES)


def parse_pip_repo_input(repo: str) -> PipTargetSpec:
    if not is_pip_repo_input(repo):
        raise ValueError(f"Not a pip repo input: {repo!r}")

    raw = repo.strip()
    prefix, rest = raw.split(":", maxsplit=1)
    rest = rest.strip()
    if not rest:
        raise ValueError(
            "package repo input must include at least one requirement after 'pip:' or 'pdm:'."
        )

    parts = shlex.split(rest, posix=True)
    requirements: list[str] = []
    for idx, item in enumerate(parts):
        if not isinstance(item, str):
            continue
        cleaned = item.strip()
        if not cleaned:
            continue
        if cleaned.startswith("-"):
            raise ValueError(
                "pip repo input only supports requirement strings (no pip flags). "
                f"got={cleaned!r} at index {idx}"
            )
        requirements.append(cleaned)

    if not requirements:
        raise ValueError("pip repo input yielded no requirements.")

    installer: Literal["pip", "pdm"] = "pdm" if prefix.strip().lower() == "pdm" else "pip"
    return PipTargetSpec(installer=installer, requirements=tuple(requirements))


def requirements_path(workspace_dir: Path) -> Path:
    return workspace_dir / PIP_TARGET_DIRNAME / PIP_REQUIREMENTS_FILENAME


def metadata_path(workspace_dir: Path) -> Path:
    return workspace_dir / PIP_TARGET_DIRNAME / PIP_TARGET_METADATA_FILENAME


def _toml_basic_string(value: str) -> str:
    escaped = value.replace("\\", "\\\\").replace('"', '\\"')
    return f'"{escaped}"'


def write_pip_target_workspace(
    *,
    workspace_dir: Path,
    repo_input: str,
    spec: PipTargetSpec,
) -> None:
    workspace_dir.mkdir(parents=True, exist_ok=True)

    (workspace_dir / ".gitignore").write_text(
        "\n".join(
            [
                ".venv/",
                "__pycache__/",
                ".pytest_cache/",
                ".mypy_cache/",
                ".ruff_cache/",
                "",
            ]
        ),
        encoding="utf-8",
    )

    meta_dir = workspace_dir / PIP_TARGET_DIRNAME
    meta_dir.mkdir(parents=True, exist_ok=True)

    requirements_path(workspace_dir).write_text(
        "\n".join([*spec.requirements, ""]),
        encoding="utf-8",
    )

    if spec.installer == "pdm":
        dep_lines = [f"    {_toml_basic_string(req)}," for req in spec.requirements]
        pyproject_lines = [
            "[project]",
            'name = "usertest-pdm-target"',
            'version = "0.0.0"',
            'description = "Synthetic workspace generated by usertest for pdm-installed targets"',
            'requires-python = ">=3.11"',
            "dependencies = [",
            *dep_lines,
            "]",
            "",
            "[tool.pdm]",
            "distribution = false",
            "",
            "[build-system]",
            'requires = ["pdm-backend>=2.0.0"]',
            'build-backend = "pdm.backend"',
            "",
        ]
        (workspace_dir / "pyproject.toml").write_text(
            "\n".join(pyproject_lines),
            encoding="utf-8",
        )

    metadata_path(workspace_dir).write_text(
        json.dumps(
            {
                "kind": "pip_target",
                "repo_input": repo_input,
                "installer": spec.installer,
                "requirements": list(spec.requirements),
            },
            indent=2,
            ensure_ascii=False,
        )
        + "\n",
        encoding="utf-8",
    )

    (workspace_dir / "README.md").write_text(
        "\n".join(
            [
                "# package target workspace",
                "",
                (
                    "This directory was generated by `usertest` to evaluate one or more Python "
                    "packages as installed artifacts (fresh install), rather than a source repo "
                    "checkout."
                ),
                "",
                f"Installer mode: `{spec.installer}`",
                "",
                "Package requirements:",
                *[f"- `{req}`" for req in spec.requirements],
                "",
                "Notes:",
                (
                    "- The runner installs these into an isolated virtualenv before invoking "
                    "the agent."
                ),
                (
                    "- If you need private index auth (e.g., GitLab PyPI), pass credentials via "
                    "environment variables (see `docs/monorepo-packages.md`)."
                ),
                (
                    "- For `pdm:` targets, the workspace includes a generated `pyproject.toml` "
                    "and the runner uses PDM bootstrap mode."
                ),
                "",
            ]
        ),
        encoding="utf-8",
    )
